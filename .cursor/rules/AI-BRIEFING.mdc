---
description: 
globs: 
alwaysApply: true
---
# AI-BRIEFING.md

## Winery Management Game – Architecture & Code Generation Guide

This briefing is for AI-assisted code generation for the **Winery Management Game**, a turn-based single-player simulation game.

---

### 🔧 Project Overview
Players manage a winery, including vineyard operations, wine production, building upgrades, staff, and sales. The game includes a simple economic engine with **formula-based wine prices** and **NPC buyers** — there is **no multiplayer or player-to-player interaction**.

---

### 💻 Frontend Architecture

- **Framework**: React + TypeScript
- **SPA Only**: No routing or Next.js. Use a `view` variable to switch between screens.
- **Styling**: Tailwind CSS, and Shadcn UI only (no Bootstrap, no custom CSS in this iteration).
- **No overlays, sidebars, or panels** in layout.
- **Components** should be functional and minimal. Avoid unnecessary abstraction.

```tsx
// Example view switching
{view === "vineyard" && <Vineyard />}
{view === "finance" && <FinanceScreen />}
```

---

### 🧠 State & Logic

- Centralize all game data and logic in `gameState.ts`.
- Use TypeScript types for entities like:
  - `Player`, `WineBatch`, `Building`, `Staff`, `Transaction`, etc.
- Avoid `useState` and `useEffect` unless absolutely necessary.
- Game logic (e.g., production, quality calculations, finances) must not live in components.
- Access state via helper functions (`getGameState()`, `updatePlayerMoney()`, etc.).

---

### 🔌 Firebase Backend

- Use **Firebase Auth** for login.
- Use **Firestore** to load/save player state (on login, logout, or tick).
- Use **Firebase Functions** for:
- Firebase do NOT support undefined values. They need to be omitted or null
  - Tick progression
  - Price calculations (e.g., land, wine, sales)
  - Simulated wine sales to NPC importers

> The game should run in memory during a session — no constant sync.

---

### 💾 Database Services Architecture

- **All database operations** must be centralized in `src/lib/database/*` services.
- **Never** implement database operations directly in components, views, or other files.
- Service modules include:
  - `storageService.ts`: For localStorage operations
  - `companyService.ts`: For company CRUD operations
  - `gameStateService.ts`: For saving/loading full game state
  - `vineyardService.ts`: For vineyard-specific operations

```tsx
// CORRECT: Import and use database services
import { addVineyard } from '../lib/database/vineyardService';

// In component:
const handleAddVineyard = async () => {
  await addVineyard(vineyardData, true); // Second param = save to DB
};

// INCORRECT: Don't use Firebase directly in components
// ❌ import { doc, setDoc } from 'firebase/firestore';
// ❌ const docRef = doc(db, "collection", "id");
// ❌ await setDoc(docRef, data);
```

- Use the `saveToDb` boolean parameter (default: false) to control whether changes persist.
- Services should handle all error states and provide appropriate responses.
- New entity services should follow the same pattern (e.g., `buildingService.ts`).

---

### 📈 Economic System

- The economy is **formula-based**, not dynamic or real-time.
- Wine prices, land values, and prestige scores are **calculated**, not simulated.
- Sales are resolved to randomized NPCs (non-interactive).

---

### 🖥️ Display Management System

- The display management system in `src/lib/displayManager.ts` is a **special exception** to our rule of avoiding React hooks.
- This system ensures all UI components update when game state changes.
- Components can subscribe to updates using the `useDisplayUpdate` hook.
- Action handlers can be wrapped with `displayManager.createActionHandler` to automatically trigger updates.

```tsx
// In a component that needs to update when game state changes
import { useDisplayUpdate } from '../lib/displayManager';

const MyComponent = () => {
  // This hook automatically registers the component for updates
  useDisplayUpdate();
  
  // Component code...
};

// For action handlers that should trigger updates
import displayManager from '../lib/displayManager';

const handleAction = displayManager.createActionHandler(() => {
  // Action code that changes game state
  updateGameState({ /* changes */ });
});
```

- The display manager is a singleton service that manages component subscriptions and updates.
- It provides methods to register/unregister components and utility functions for wrapping action handlers.
- This approach is justified because it naturally integrates with React's component lifecycle, provides better performance, and simplifies component code.

---

### 🔄 Activity and Work Calculation System

#### Work Categories and Tasks

- The game uses specific **WorkCategory** enum values for different tasks:
  - `PLANTING`, `HARVESTING`, `CRUSHING`, `FERMENTATION`, etc.
  - These categories are defined in `workCalculator.ts`
  - Do NOT create generic categories like "FIELD_WORK" or "WINERY_WORK"

- Each task category has specific **processing rates**:
  - Example: `STAFF_SEARCH` can process 5 candidates/week
  - Processing rates are defined in `TASK_RATES` in `workCalculator.ts`

- Tasks may have **initial setup work**:
  - Example: `STAFF_SEARCH` requires 25 units of initial work
  - Initial work values are defined in `INITIAL_WORK` in `workCalculator.ts`

#### Work Calculation Logic

- Work is calculated based on **realistic amounts** a worker can perform per week:
  - `BASE_WORK_UNITS` (50) represents a standard worker's weekly output
  - Formula: `(amount ÷ rate × BASE_WORK_UNITS) + initialWork`

- When adding a new task type:
  1. Add it to the `WorkCategory` enum
  2. Define its processing rate in `TASK_RATES`
  3. Define any initial work in `INITIAL_WORK` if needed

```typescript
// Example work calculation for hiring 3 staff candidates
const workUnits = calculateTotalWork(3, {
  category: WorkCategory.STAFF_SEARCH
});
// 3 candidates ÷ 5 candidates/week × 50 base units + 25 initial = 55 work units
```

#### Activity System

- Activities track work progress over time:
  - Each activity has a category, total work, and applied work
  - Staff can be assigned to activities to contribute work
  - Activities complete when applied work reaches total work

- When implementing new activities:
  1. Use existing specific work categories
  2. Use `calculateTotalWork()` for work calculations
  3. Connect to the activity manager system

- The staff skill system determines how efficiently staff contribute to activities:
  - Staff have skills in different areas (field, winery, etc.)
  - Skills map to work categories via `mapCategoryToSkill()`

#### Integration with UI

- Use `ActivityProgressBar` to display activity progress
- Use `ActivityOptionsModal` for configuring activities
- Use `useActivity` hook to manage activity state and lifecycle

---

### ✅ AI Code Rules Summary

1. **React + TypeScript SPA**, no routing.
2. Use a single `view` switcher for navigation.
3. All state and logic in `gameState.ts`.
4. Avoid scattered hooks — central logic only.
5. Use Tailwind for styling.
6. No multiplayer, market, or trade logic.
7. Keep database interactions minimal and **only in database services**.
8. Simulated NPC wine sales only — no real-time buyer simulation.
9. Use the display management system for UI updates (exception to the hooks rule).

---


# Display Management System

## Overview

The Display Management System is a special exception to our general rule of avoiding React hooks. It provides a centralized way to update UI components when game state changes, ensuring that all displays remain in sync with the underlying data.

## Why Hooks in This Case?

While our general architecture rule is to avoid React hooks, the display management system is a justified exception for the following reasons:

1. **Component Lifecycle Integration**: Hooks naturally integrate with React's component lifecycle, automatically handling registration on mount and cleanup on unmount. This prevents memory leaks and ensures components only receive updates when they're actually mounted.

2. **Declarative Approach**: The hook-based approach is more declarative, making it clear which components need to update when game state changes. This improves code readability and maintainability.

3. **Performance Optimization**: React's built-in state management through hooks allows for more efficient rendering. Components only re-render when necessary, rather than on every game state change.

4. **Simplified Component Code**: Components using the hook don't need to implement complex subscription logic themselves - they just call `useDisplayUpdate()` and everything is handled automatically.

5. **TypeScript Integration**: The hook approach works seamlessly with TypeScript, providing better type safety and developer experience.

6. **Consistent with React Patterns**: This approach aligns with React's recommended patterns for side effects and state management, making it more intuitive for React developers.

## Architecture

The display management system consists of:

1. **DisplayManager Class**: A singleton service that manages component subscriptions and updates.
2. **useDisplayUpdate Hook**: A React hook for components to subscribe to updates.
3. **Action Handler Utilities**: Functions to wrap action handlers with automatic display updates.

## Usage

### In Components

```tsx
import { useDisplayUpdate } from '../lib/displayManager';

const MyComponent = () => {
  // This hook automatically registers the component for updates
  useDisplayUpdate();
  
  // Get current game state
  const gameState = getGameState();
  
  // Component code...
};
```

### For Action Handlers

```tsx
import displayManager from '../lib/displayManager';

const handleAction = displayManager.createActionHandler(() => {
  // Action code that changes game state
  updateGameState({ /* changes */ });
});
```

## Integration with Game State

The display management system is integrated with the game state system to automatically update displays when game state changes:

1. **gameState.ts**: Calls `displayManager.updateAllDisplays()` when game state changes.
2. **gameTick.ts**: Calls `displayManager.updateAllDisplays()` after game ticks and events.

## Best Practices

1. **Use the Hook in Components**: Always use the `useDisplayUpdate` hook in components that display game state.
2. **Wrap Action Handlers**: Use `displayManager.createActionHandler` for action handlers that change game state.
3. **Avoid Direct DOM Manipulation**: Never directly manipulate the DOM in components - let React handle rendering.
4. **Keep Components Simple**: Components should focus on rendering and user interaction, not game logic.

## Example Component

### Status Component

```tsx
import React from 'react';
import { getGameState } from '../gameState';
import { useDisplayUpdate } from '../lib/displayManager';

const Status: React.FC = () => {
  // Use our display update hook to automatically refresh when game state changes
  useDisplayUpdate();
  
  // Get current game state
  const gameState = getGameState();
  const { player, week, season, currentYear } = gameState;
  
  if (!player) {
    return null;
  }
  
  return (
    <div className="bg-white rounded-lg shadow p-4">
      <h2 className="text-xl font-semibold text-wine mb-3">Company Status</h2>
      
      <div className="grid grid-cols-2 gap-3">
        <div>
          <p className="text-sm text-gray-500">Company</p>
          <p className="font-medium">{player.companyName}</p>
        </div>
        
        <div>
          <p className="text-sm text-gray-500">Current Date</p>
          <p className="font-medium">Week {week}, {season} {currentYear}</p>
        </div>
        
        {/* More status information */}
      </div>
    </div>
  );
};

export default Status;
``` 